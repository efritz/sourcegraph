//
// An index contains one or more dimensions of intelligence about a given piece
// of source code or software artifact. Complimentary dimensions can be merged
// together from multiple sources to provide a unified code intelligence
// experience.
//
// Programs producing a file of this format is an "indexer" and may operate
// somewhere on the spectrum between precision, such as indexes produced by
// compiler-backed indexers, and heurstics, such as indexes produced by local
// syntax-directed analysis for scope rules.
//
// Indexes can be emitted and consumed "packed" or "streamed". See `PackedIndex`
// and `IndexMessage`, respectively, for additional documentation.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.1
// 	protoc        (unknown)
// source: lib/codeintel/lsif_typed/lsif.proto

package lsif_typed

import (
	reflect "reflect"
	sync "sync"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

//
// Possible index protocol versions.
type Metadata_ProtocolVersion int32

const (
	//
	// Currently, the only version available while the protocol is in
	// design-flux. Once we are reasonably sure about the direction of this
	// protocol, we will create a new non-zero version and enforce a version
	// check in consumers for safety and forwards-compatibility.
	Metadata_UnspecifiedProtocolVersion Metadata_ProtocolVersion = 0
)

// Enum value maps for Metadata_ProtocolVersion.
var (
	Metadata_ProtocolVersion_name = map[int32]string{
		0: "UnspecifiedProtocolVersion",
	}
	Metadata_ProtocolVersion_value = map[string]int32{
		"UnspecifiedProtocolVersion": 0,
	}
)

func (x Metadata_ProtocolVersion) Enum() *Metadata_ProtocolVersion {
	p := new(Metadata_ProtocolVersion)
	*p = x
	return p
}

func (x Metadata_ProtocolVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Metadata_ProtocolVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[0].Descriptor()
}

func (Metadata_ProtocolVersion) Type() protoreflect.EnumType {
	return &file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[0]
}

func (x Metadata_ProtocolVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Metadata_ProtocolVersion.Descriptor instead.
func (Metadata_ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{2, 0}
}

//
// Possible text document encodings.
type Metadata_Encoding int32

const (
	//
	// (Invalid) Unknown encoding. Consumers may attempt to choose a sane
	// default or auto-detect an encoding of text documents when rendering
	// selections of code.
	Metadata_UnspecifiedEncoding Metadata_Encoding = 0
	//
	// Text documents are encoded in UTF-8.
	Metadata_UTF8 Metadata_Encoding = 1
	//
	// Text documents are encoded in UTF-16 (e.g., TypeScript).
	Metadata_UTF16 Metadata_Encoding = 2
)

// Enum value maps for Metadata_Encoding.
var (
	Metadata_Encoding_name = map[int32]string{
		0: "UnspecifiedEncoding",
		1: "UTF8",
		2: "UTF16",
	}
	Metadata_Encoding_value = map[string]int32{
		"UnspecifiedEncoding": 0,
		"UTF8":                1,
		"UTF16":               2,
	}
)

func (x Metadata_Encoding) Enum() *Metadata_Encoding {
	p := new(Metadata_Encoding)
	*p = x
	return p
}

func (x Metadata_Encoding) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Metadata_Encoding) Descriptor() protoreflect.EnumDescriptor {
	return file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[1].Descriptor()
}

func (Metadata_Encoding) Type() protoreflect.EnumType {
	return &file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[1]
}

func (x Metadata_Encoding) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Metadata_Encoding.Descriptor instead.
func (Metadata_Encoding) EnumDescriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{2, 1}
}

//
// Possible tags associated with a selection of text within a document used
// for syntax or semantic-directed highlighting.
type Document_Occurrence_HighlightClass int32

const (
	//
	// Unknown highlighting class. Do not apply special styling beyond the
	// default "code style" for the associated range.
	Document_Occurrence_UnspecifiedHighlightClass Document_Occurrence_HighlightClass = 0
)

// Enum value maps for Document_Occurrence_HighlightClass.
var (
	Document_Occurrence_HighlightClass_name = map[int32]string{
		0: "UnspecifiedHighlightClass",
	}
	Document_Occurrence_HighlightClass_value = map[string]int32{
		"UnspecifiedHighlightClass": 0,
	}
)

func (x Document_Occurrence_HighlightClass) Enum() *Document_Occurrence_HighlightClass {
	p := new(Document_Occurrence_HighlightClass)
	*p = x
	return p
}

func (x Document_Occurrence_HighlightClass) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Document_Occurrence_HighlightClass) Descriptor() protoreflect.EnumDescriptor {
	return file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[2].Descriptor()
}

func (Document_Occurrence_HighlightClass) Type() protoreflect.EnumType {
	return &file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[2]
}

func (x Document_Occurrence_HighlightClass) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Document_Occurrence_HighlightClass.Descriptor instead.
func (Document_Occurrence_HighlightClass) EnumDescriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{3, 0, 0}
}

//
// The type of relationship between an occurrence and a symbol.
type Document_Occurrence_SymbolRelation_RelationshipType int32

const (
	//
	// (Invalid) Unknown relationship type.
	Document_Occurrence_SymbolRelation_UnspecifiedRelationshipType Document_Occurrence_SymbolRelation_RelationshipType = 0
	//
	// The source occurrence defines the target symbol (e.g., `x` in `val x
	// = y`).
	Document_Occurrence_SymbolRelation_DefinitionOf Document_Occurrence_SymbolRelation_RelationshipType = 1
	//
	// The source occurrence references the target symbol, which is defined
	// elsewhere (e.g., `y` in `val x = y`).
	Document_Occurrence_SymbolRelation_ReferenceTo Document_Occurrence_SymbolRelation_RelationshipType = 2
)

// Enum value maps for Document_Occurrence_SymbolRelation_RelationshipType.
var (
	Document_Occurrence_SymbolRelation_RelationshipType_name = map[int32]string{
		0: "UnspecifiedRelationshipType",
		1: "DefinitionOf",
		2: "ReferenceTo",
	}
	Document_Occurrence_SymbolRelation_RelationshipType_value = map[string]int32{
		"UnspecifiedRelationshipType": 0,
		"DefinitionOf":                1,
		"ReferenceTo":                 2,
	}
)

func (x Document_Occurrence_SymbolRelation_RelationshipType) Enum() *Document_Occurrence_SymbolRelation_RelationshipType {
	p := new(Document_Occurrence_SymbolRelation_RelationshipType)
	*p = x
	return p
}

func (x Document_Occurrence_SymbolRelation_RelationshipType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Document_Occurrence_SymbolRelation_RelationshipType) Descriptor() protoreflect.EnumDescriptor {
	return file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[3].Descriptor()
}

func (Document_Occurrence_SymbolRelation_RelationshipType) Type() protoreflect.EnumType {
	return &file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[3]
}

func (x Document_Occurrence_SymbolRelation_RelationshipType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Document_Occurrence_SymbolRelation_RelationshipType.Descriptor instead.
func (Document_Occurrence_SymbolRelation_RelationshipType) EnumDescriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{3, 0, 0, 0}
}

//
// The type of relationship between two symbols.
type SymbolInformation_SymbolRelation_RelationshipType int32

const (
	//
	// (Invalid) Unknown relationship type.
	SymbolInformation_SymbolRelation_UnspecifiedRelationshipType SymbolInformation_SymbolRelation_RelationshipType = 0
	//
	// The source symbol has a type described by the target symbol.
	//
	// For example, symbols `s{1..3}` are all type references to symbol `S` in
	// the following:
	//
	// ```go
	// type S struct {}  // def S
	// var s1, s2, s3 S  // def s{1..3}, ref S
	// _ = s1            // ref s1
	// ```
	//
	// This type of relationship affords the "Go to type definition" code
	// navigation action.
	SymbolInformation_SymbolRelation_TypeReferenceTo SymbolInformation_SymbolRelation_RelationshipType = 1
	//
	// The source symbol is an implementation of the target symbol.
	//
	// For example, symbols `S` and `S.M` are respective implementations of
	// symbols `I` and `I.M` in the following:
	//
	// ```go
	// type I interface{ M() }  // def I, def I.M
	// type S struct{}          // def S
	// func (S) M() {}          // ref S, def S.M
	// ```
	//
	// This type of relationship affords us the "Go to interface" and "Find
	// implementations" code naviagation actions; it can also expand the set
	// of results for a "Find references" operation, where references of the
	// interface include references of concrete types as well, but not the
	// reverse.
	SymbolInformation_SymbolRelation_ImplementationOf SymbolInformation_SymbolRelation_RelationshipType = 2
)

// Enum value maps for SymbolInformation_SymbolRelation_RelationshipType.
var (
	SymbolInformation_SymbolRelation_RelationshipType_name = map[int32]string{
		0: "UnspecifiedRelationshipType",
		1: "TypeReferenceTo",
		2: "ImplementationOf",
	}
	SymbolInformation_SymbolRelation_RelationshipType_value = map[string]int32{
		"UnspecifiedRelationshipType": 0,
		"TypeReferenceTo":             1,
		"ImplementationOf":            2,
	}
)

func (x SymbolInformation_SymbolRelation_RelationshipType) Enum() *SymbolInformation_SymbolRelation_RelationshipType {
	p := new(SymbolInformation_SymbolRelation_RelationshipType)
	*p = x
	return p
}

func (x SymbolInformation_SymbolRelation_RelationshipType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SymbolInformation_SymbolRelation_RelationshipType) Descriptor() protoreflect.EnumDescriptor {
	return file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[4].Descriptor()
}

func (SymbolInformation_SymbolRelation_RelationshipType) Type() protoreflect.EnumType {
	return &file_lib_codeintel_lsif_typed_lsif_proto_enumTypes[4]
}

func (x SymbolInformation_SymbolRelation_RelationshipType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SymbolInformation_SymbolRelation_RelationshipType.Descriptor instead.
func (SymbolInformation_SymbolRelation_RelationshipType) EnumDescriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{4, 1, 0}
}

//
// A representation of an index that can be emitted and consumed as as single
// message payload. To write and consume a stream of messages instead, see
// `IndexMessage`.
type PackedIndex struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) Metadata about this index such as tool and protocol versioning
	// and identification of the indexing environment.
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	//
	// (Optional) Representations of decorated text documents that compose the
	// analyzed source of this index.
	Documents []*Document `protobuf:"bytes,2,rep,name=documents,proto3" json:"documents,omitempty"`
	//
	// (Optional) Representations of objects within the analyzed source of this
	// index. Referenced by one or more occurrences within the documents of this
	// index, or externally from another index (by uniquely defined identifiers).
	SymbolInformation []*SymbolInformation `protobuf:"bytes,3,rep,name=symbol_information,json=symbolInformation,proto3" json:"symbol_information,omitempty"`
}

func (x *PackedIndex) Reset() {
	*x = PackedIndex{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PackedIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackedIndex) ProtoMessage() {}

func (x *PackedIndex) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackedIndex.ProtoReflect.Descriptor instead.
func (*PackedIndex) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{0}
}

func (x *PackedIndex) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PackedIndex) GetDocuments() []*Document {
	if x != nil {
		return x.Documents
	}
	return nil
}

func (x *PackedIndex) GetSymbolInformation() []*SymbolInformation {
	if x != nil {
		return x.SymbolInformation
	}
	return nil
}

//
// A representation of a portion of an index. An entire index can be represented
// by a length-prefixed stream of index messages with the following ordering
// constraints:
//
// 1. The first message in the stream is (the only) metadata message.
// 2. All symbol messages are emitted before any document message that
// references it. Note that symbols may reference each other, and a symbol
// object may not be logically "closed" until the end of the stream.
//
// These constraints allow the index to be processed with minimal bookkeeping
// overhead, and allows partial processing to stop early on successful match.
type IndexMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// Union of message payload types.
	//
	// Types that are assignable to Value:
	//	*IndexMessage_Metadata
	//	*IndexMessage_Document
	//	*IndexMessage_SymbolInformation
	Value isIndexMessage_Value `protobuf_oneof:"value"`
}

func (x *IndexMessage) Reset() {
	*x = IndexMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IndexMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexMessage) ProtoMessage() {}

func (x *IndexMessage) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexMessage.ProtoReflect.Descriptor instead.
func (*IndexMessage) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{1}
}

func (m *IndexMessage) GetValue() isIndexMessage_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (x *IndexMessage) GetMetadata() *Metadata {
	if x, ok := x.GetValue().(*IndexMessage_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (x *IndexMessage) GetDocument() *Document {
	if x, ok := x.GetValue().(*IndexMessage_Document); ok {
		return x.Document
	}
	return nil
}

func (x *IndexMessage) GetSymbolInformation() *SymbolInformation {
	if x, ok := x.GetValue().(*IndexMessage_SymbolInformation); ok {
		return x.SymbolInformation
	}
	return nil
}

type isIndexMessage_Value interface {
	isIndexMessage_Value()
}

type IndexMessage_Metadata struct {
	//
	// Metadata about this index such as tool and protocol
	// versioning and identification of the indexing environment.
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3,oneof"`
}

type IndexMessage_Document struct {
	//
	// A representation of a decorated text document contained in in
	// the analyzed source of this index.
	Document *Document `protobuf:"bytes,2,opt,name=document,proto3,oneof"`
}

type IndexMessage_SymbolInformation struct {
	//
	// A representation of an object within the analyzed source of this index.
	// Referenced by one or more occurrences within the documents of this index,
	// or externally from another index (by uniquely defined identifiers).
	SymbolInformation *SymbolInformation `protobuf:"bytes,3,opt,name=symbol_information,json=symbolInformation,proto3,oneof"`
}

func (*IndexMessage_Metadata) isIndexMessage_Value() {}

func (*IndexMessage_Document) isIndexMessage_Value() {}

func (*IndexMessage_SymbolInformation) isIndexMessage_Value() {}

//
// Metadata contains tool and protocol version information, indexer
// self-identification, and data that encodes the indexing environment. Unlike
// the other messages defined in this index, the contents of this message may
// not be "stable" bewteen indexer invocations producing the same logical index
// (for example, `Metadata.project_root` encodes the local working directory).
type Metadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) An explicit version of the encoding used for this index. Changes
	// to this value may change the interpretation of parsed strings (such as
	// symbol identifiers) in tools consuming the index.
	ProtocolVersion Metadata_ProtocolVersion `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3,enum=lib.codeintel.lsif_typed.Metadata_ProtocolVersion" json:"protocol_version,omitempty"`
	//
	// (Required) Information about the tool that created the index.
	ToolInfo *Metadata_ToolInfo `protobuf:"bytes,2,opt,name=tool_info,json=toolInfo,proto3" json:"tool_info,omitempty"`
	//
	// (Required) A URI-encoded absolute path to the root directory of this
	// index. The documents also contained in the associated index are defined
	// relative to this directory.
	ProjectRoot string `protobuf:"bytes,3,opt,name=project_root,json=projectRoot,proto3" json:"project_root,omitempty"`
	//
	// (Required) The string encoding used to compute correct text selections
	// within the text documents defining the indexed source code. Positions
	// within text documents are expressed as zero-based line and character
	// offsets based on the string representations of the text with the given
	// encoding.
	TextDocumentEncoding Metadata_Encoding `protobuf:"varint,4,opt,name=text_document_encoding,json=textDocumentEncoding,proto3,enum=lib.codeintel.lsif_typed.Metadata_Encoding" json:"text_document_encoding,omitempty"`
}

func (x *Metadata) Reset() {
	*x = Metadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Metadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata) ProtoMessage() {}

func (x *Metadata) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{2}
}

func (x *Metadata) GetProtocolVersion() Metadata_ProtocolVersion {
	if x != nil {
		return x.ProtocolVersion
	}
	return Metadata_UnspecifiedProtocolVersion
}

func (x *Metadata) GetToolInfo() *Metadata_ToolInfo {
	if x != nil {
		return x.ToolInfo
	}
	return nil
}

func (x *Metadata) GetProjectRoot() string {
	if x != nil {
		return x.ProjectRoot
	}
	return ""
}

func (x *Metadata) GetTextDocumentEncoding() Metadata_Encoding {
	if x != nil {
		return x.TextDocumentEncoding
	}
	return Metadata_UnspecifiedEncoding
}

//
// A representation a text document belonging to the associated index decorated
// with addiditonal intelligence. We assume that all relevant indexed documents
// can be represented as a string. There is currently no support for binary
// documents. The character encoding of a document is delcared by the associated
// index's `Metadata.text_document_encoding` field.
type Document struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) The path to the text document relative to the directory supplied
	// in the associated `Index.project_root`. This value should not begin with a
	// directory separator.
	RelativePath string `protobuf:"bytes,1,opt,name=relative_path,json=relativePath,proto3" json:"relative_path,omitempty"`
	//
	// (Optional) A set of occurrences that provide additional intelligence for
	// some selection of source text within the document.
	Occurrences []*Document_Occurrence `protobuf:"bytes,2,rep,name=occurrences,proto3" json:"occurrences,omitempty"`
}

func (x *Document) Reset() {
	*x = Document{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Document) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Document) ProtoMessage() {}

func (x *Document) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Document.ProtoReflect.Descriptor instead.
func (*Document) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{3}
}

func (x *Document) GetRelativePath() string {
	if x != nil {
		return x.RelativePath
	}
	return ""
}

func (x *Document) GetOccurrences() []*Document_Occurrence {
	if x != nil {
		return x.Occurrences
	}
	return nil
}

//
// A representation of an object within the analyzed source of this index that
// may be referenced by one or more occurrences within this index, or externally
// from another index (by uniquely defined identifiers).
type SymbolInformation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) An identifier of this symbol that uniquely identifies it
	// within the associated index. This value may be used to reference the entire
	// symbol information type from the fields
	// `Document.Occurrence.SymbolRelation` and `SymbolInformation.SymbolRelation`
	// also defined in the associated index.
	//
	// Identifiers must begin with a protocol declaration, specifically the
	// prefix `{scheme}://`, that determines whether or not the
	// remainder of the value cn be used to extract semantic value. Note that we
	// do not expect this value to be a valid or parseable URI, nor do we expect
	// any particular encoding of the remaining payload.
	//
	// Within a particular scheme, identifiers should be sufficiently unique so as
	// to avoid matching other symbols in other projects unless they actuall refer
	// to the same symbol. Symbol identifiers should be position-independent and
	// stable so that they can be used to identify symbols between documents and
	// projects.
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	//
	// (Optional) The package in which this symbol is defined. Package values are
	// compared bewteen distinct indexes to enable global navigation.
	Package *SymbolInformation_Package `protobuf:"bytes,2,opt,name=package,proto3" json:"package,omitempty"`
	//
	// (Optional) The documentation payload for this symbol encoded as markdown.
	// This field is repeated to allow different kinds of documentation. For
	// example, separating signature from description.
	Documentation []string `protobuf:"bytes,3,rep,name=documentation,proto3" json:"documentation,omitempty"`
	//
	// (Optional) A set of (directed) relationships between this symbol and other
	// symbols also defined in the associated index. These relationships define
	// groups of symbols that should be transitively evaluated and treated as one
	// entity when resolving specific types of code navigation queries. See
	// `SymbolInformation.SymbolRelation.relationship_type` for additional
	// documentation.
	Relatives []*SymbolInformation_SymbolRelation `protobuf:"bytes,4,rep,name=relatives,proto3" json:"relatives,omitempty"`
}

func (x *SymbolInformation) Reset() {
	*x = SymbolInformation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SymbolInformation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SymbolInformation) ProtoMessage() {}

func (x *SymbolInformation) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SymbolInformation.ProtoReflect.Descriptor instead.
func (*SymbolInformation) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{4}
}

func (x *SymbolInformation) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *SymbolInformation) GetPackage() *SymbolInformation_Package {
	if x != nil {
		return x.Package
	}
	return nil
}

func (x *SymbolInformation) GetDocumentation() []string {
	if x != nil {
		return x.Documentation
	}
	return nil
}

func (x *SymbolInformation) GetRelatives() []*SymbolInformation_SymbolRelation {
	if x != nil {
		return x.Relatives
	}
	return nil
}

//
// A description of the indexer (and the invocation) that produced the
// associated index.
type Metadata_ToolInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) The name of the tool that created the associated index.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	//
	// (Required) The version of the tool that created the associated index.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	//
	// (Required) The list of command line arguments supplied to the indexer
	// that created the associated index.
	Arguments []string `protobuf:"bytes,3,rep,name=arguments,proto3" json:"arguments,omitempty"`
}

func (x *Metadata_ToolInfo) Reset() {
	*x = Metadata_ToolInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Metadata_ToolInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata_ToolInfo) ProtoMessage() {}

func (x *Metadata_ToolInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata_ToolInfo.ProtoReflect.Descriptor instead.
func (*Metadata_ToolInfo) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{2, 0}
}

func (x *Metadata_ToolInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Metadata_ToolInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Metadata_ToolInfo) GetArguments() []string {
	if x != nil {
		return x.Arguments
	}
	return nil
}

//
// An occurrence associates a selection of source text with additional code
// intelligence, such as highlighting rules or answers to common code
// navigation queries such as finding hover text, definitions, references,
// or implementations of the symbol at a specific source text position.
type Document_Occurrence struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) A range of contiguous characters in the enclosing text
	// document expressed a half-open interval (start inclusive; end exclusive).
	//
	// Both line and character offsets are zero-based. Make sure to adjust line
	// and character values before displaying them in an editor-like UI as
	// editors conventionally count from one.
	//
	// This value must have exactly three or four elements of either the form
	// `[a, b, d]` or `[a, b, c, d]` where `a` is the starting line, `b` is the
	// starting column, `c` is the ending line, and `d` is the ending column.
	// The three-element form should only be used when `a = c`, i.e., the case
	// of single-line ranges. The initial encoding of ranges in this spec used a
	// `Range` message type that mirrors the structure of the equivalent type in
	// LSP. Benchmarks revealed we were able to reduce the total payload size of
	// the entire index by up to ~2x by using a `repeated int32` encoding
	// instead, which has an efficient packed encoding in Protobuf binary
	// payloads. efficient encoding. This value must have exactly three or four
	// elements of either the form `[a, b, d]` or `[a, b, c, d]` where `a` is
	// the starting line, `b` is the starting column, `c` is the ending line,
	// and `d` is the ending column. The three-element form should be used if
	// and only if `a = c`, i.e., the case of single-line ranges.
	//
	// Lines exceeding the document line count or characters exceeding the
	// length of the target line will be interpreted as the maximum valid value
	// given the text document contents (and according to its encoding).
	//
	// Special values like -1 to indicate the end of a line are not allowed. If
	// you want to specify a range that contains a line including the line
	// ending character(s) then use an end position denoting the start of the
	// next line.
	//
	// For example: `[5, 23, 6, 0]`
	Range []uint32 `protobuf:"varint,1,rep,packed,name=range,proto3" json:"range,omitempty"`
	//
	// (Optional) A set of (directed) relationships between this occurrence and
	// symbols also defined in the associated index. Values for this field may
	// not be provided if this occurrence is used only for highlighting.
	Relatives []*Document_Occurrence_SymbolRelation `protobuf:"bytes,2,rep,name=relatives,proto3" json:"relatives,omitempty"`
	//
	// (Optional) The type of syntax highlighting class that should be used for
	// the associated range. If unspecified, no presentation properties are
	// prescribed.
	HighlightClass Document_Occurrence_HighlightClass `protobuf:"varint,3,opt,name=highlight_class,json=highlightClass,proto3,enum=lib.codeintel.lsif_typed.Document_Occurrence_HighlightClass" json:"highlight_class,omitempty"`
}

func (x *Document_Occurrence) Reset() {
	*x = Document_Occurrence{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Document_Occurrence) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Document_Occurrence) ProtoMessage() {}

func (x *Document_Occurrence) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Document_Occurrence.ProtoReflect.Descriptor instead.
func (*Document_Occurrence) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{3, 0}
}

func (x *Document_Occurrence) GetRange() []uint32 {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *Document_Occurrence) GetRelatives() []*Document_Occurrence_SymbolRelation {
	if x != nil {
		return x.Relatives
	}
	return nil
}

func (x *Document_Occurrence) GetHighlightClass() Document_Occurrence_HighlightClass {
	if x != nil {
		return x.HighlightClass
	}
	return Document_Occurrence_UnspecifiedHighlightClass
}

//
// A description of the relationship between a source occurrence and a
// symbol.
type Document_Occurrence_SymbolRelation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) A reference to the target `SymbolInformation.symbol`. This
	// symbol may be defined in the same associated index, or a remote one.
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	//
	// (Required) The type of relationship between the target symbol and the
	// source occurrence. See `Document.SymbolRelation.relationship_type` for
	// additional documentation relating to each possible relationship type.
	RelationshipType Document_Occurrence_SymbolRelation_RelationshipType `protobuf:"varint,2,opt,name=relationship_type,json=relationshipType,proto3,enum=lib.codeintel.lsif_typed.Document_Occurrence_SymbolRelation_RelationshipType" json:"relationship_type,omitempty"`
	//
	// (Optional) Range-specific overrides for the documentation string
	// defiend in the referenced symbol. This useful when the definition of a
	// symbol may be parameteric, but the usage of a symbol may have refined
	// typing information in the signature that would be more useful to
	// display.
	OverrideDocumentation []string `protobuf:"bytes,3,rep,name=override_documentation,json=overrideDocumentation,proto3" json:"override_documentation,omitempty"`
}

func (x *Document_Occurrence_SymbolRelation) Reset() {
	*x = Document_Occurrence_SymbolRelation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Document_Occurrence_SymbolRelation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Document_Occurrence_SymbolRelation) ProtoMessage() {}

func (x *Document_Occurrence_SymbolRelation) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Document_Occurrence_SymbolRelation.ProtoReflect.Descriptor instead.
func (*Document_Occurrence_SymbolRelation) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{3, 0, 0}
}

func (x *Document_Occurrence_SymbolRelation) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *Document_Occurrence_SymbolRelation) GetRelationshipType() Document_Occurrence_SymbolRelation_RelationshipType {
	if x != nil {
		return x.RelationshipType
	}
	return Document_Occurrence_SymbolRelation_UnspecifiedRelationshipType
}

func (x *Document_Occurrence_SymbolRelation) GetOverrideDocumentation() []string {
	if x != nil {
		return x.OverrideDocumentation
	}
	return nil
}

//
// Package describes a publishable, versioned, and uniquely identifiable
// artifact such as a Go module, an NPM or Python package, a Docker container,
// a JVM dependency, or a Cargo crate.
type SymbolInformation_Package struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) The name of the package manager (e.g., `gomod`, `npm`,
	// `maven`).
	PackageManager string `protobuf:"bytes,1,opt,name=package_manager,json=packageManager,proto3" json:"package_manager,omitempty"`
	//
	// (Required) The name of this package (e.g., `@types/react`,
	// `com.google.guava:guava`).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	//
	// (Required) The version of this package (e.g., `0.1.0`, `2.1.5`).
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *SymbolInformation_Package) Reset() {
	*x = SymbolInformation_Package{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SymbolInformation_Package) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SymbolInformation_Package) ProtoMessage() {}

func (x *SymbolInformation_Package) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SymbolInformation_Package.ProtoReflect.Descriptor instead.
func (*SymbolInformation_Package) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{4, 0}
}

func (x *SymbolInformation_Package) GetPackageManager() string {
	if x != nil {
		return x.PackageManager
	}
	return ""
}

func (x *SymbolInformation_Package) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SymbolInformation_Package) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

//
// A description of the relationship between two symbols.
type SymbolInformation_SymbolRelation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//
	// (Required) A reference to the target `SymbolInformation.symbol`. This
	// symbol may be defined in the same associated index, or a remote one.
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	//
	// (Required) The type of relationship between the target symbol and the
	// source symbol. See `SymbolInformation.SymbolRelation.relationship_type`
	// for additional documentation relating to each possible relationship type.
	RelationshipType SymbolInformation_SymbolRelation_RelationshipType `protobuf:"varint,2,opt,name=relationship_type,json=relationshipType,proto3,enum=lib.codeintel.lsif_typed.SymbolInformation_SymbolRelation_RelationshipType" json:"relationship_type,omitempty"`
}

func (x *SymbolInformation_SymbolRelation) Reset() {
	*x = SymbolInformation_SymbolRelation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SymbolInformation_SymbolRelation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SymbolInformation_SymbolRelation) ProtoMessage() {}

func (x *SymbolInformation_SymbolRelation) ProtoReflect() protoreflect.Message {
	mi := &file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SymbolInformation_SymbolRelation.ProtoReflect.Descriptor instead.
func (*SymbolInformation_SymbolRelation) Descriptor() ([]byte, []int) {
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP(), []int{4, 1}
}

func (x *SymbolInformation_SymbolRelation) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *SymbolInformation_SymbolRelation) GetRelationshipType() SymbolInformation_SymbolRelation_RelationshipType {
	if x != nil {
		return x.RelationshipType
	}
	return SymbolInformation_SymbolRelation_UnspecifiedRelationshipType
}

var File_lib_codeintel_lsif_typed_lsif_proto protoreflect.FileDescriptor

var file_lib_codeintel_lsif_typed_lsif_proto_rawDesc = []byte{
	0x0a, 0x23, 0x6c, 0x69, 0x62, 0x2f, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2f,
	0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2f, 0x6c, 0x73, 0x69, 0x66, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69,
	0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x22,
	0xeb, 0x01, 0x0a, 0x0b, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x64, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x3e, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x22, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65,
	0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12,
	0x40, 0x0a, 0x09, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74,
	0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x44, 0x6f,
	0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x09, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
	0x73, 0x12, 0x5a, 0x0a, 0x12, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x66, 0x6f,
	0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e,
	0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73,
	0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x49,
	0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x11, 0x73, 0x79, 0x6d, 0x62,
	0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0xf9, 0x01,
	0x0a, 0x0c, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x40,
	0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x22, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c,
	0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x12, 0x40, 0x0a, 0x08, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74,
	0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x44, 0x6f,
	0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x08, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65,
	0x6e, 0x74, 0x12, 0x5c, 0x0a, 0x12, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x66,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b,
	0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c,
	0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
	0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x11, 0x73,
	0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x42, 0x07, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xfe, 0x03, 0x0a, 0x08, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x5d, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x32, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c,
	0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x48, 0x0a, 0x09, 0x74, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e,
	0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63,
	0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79,
	0x70, 0x65, 0x64, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x6f, 0x6f,
	0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x74, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12,
	0x21, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x52, 0x6f,
	0x6f, 0x74, 0x12, 0x61, 0x0a, 0x16, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x64, 0x6f, 0x63, 0x75, 0x6d,
	0x65, 0x6e, 0x74, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74,
	0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x52,
	0x14, 0x74, 0x65, 0x78, 0x74, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x63,
	0x6f, 0x64, 0x69, 0x6e, 0x67, 0x1a, 0x56, 0x0a, 0x08, 0x54, 0x6f, 0x6f, 0x6c, 0x49, 0x6e, 0x66,
	0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12,
	0x1c, 0x0a, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x22, 0x31, 0x0a,
	0x0f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x12, 0x1e, 0x0a, 0x1a, 0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x10, 0x00,
	0x22, 0x38, 0x0a, 0x08, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x17, 0x0a, 0x13,
	0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x45, 0x6e, 0x63, 0x6f, 0x64,
	0x69, 0x6e, 0x67, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x55, 0x54, 0x46, 0x38, 0x10, 0x01, 0x12,
	0x09, 0x0a, 0x05, 0x55, 0x54, 0x46, 0x31, 0x36, 0x10, 0x02, 0x22, 0xcf, 0x05, 0x0a, 0x08, 0x44,
	0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x6c, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x50, 0x61, 0x74, 0x68, 0x12, 0x4f, 0x0a, 0x0b,
	0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x2d, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65,
	0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x44, 0x6f, 0x63,
	0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65,
	0x52, 0x0b, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x1a, 0xcc, 0x04,
	0x0a, 0x0a, 0x4f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x05, 0x72, 0x61, 0x6e,
	0x67, 0x65, 0x12, 0x5a, 0x0a, 0x09, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65,
	0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64,
	0x2e, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4f, 0x63, 0x63, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x63, 0x65, 0x2e, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x52, 0x65, 0x6c, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x09, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x12, 0x65,
	0x0a, 0x0f, 0x68, 0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x63, 0x6c, 0x61, 0x73,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3c, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f,
	0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70,
	0x65, 0x64, 0x2e, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4f, 0x63, 0x63, 0x75,
	0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x2e, 0x48, 0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74,
	0x43, 0x6c, 0x61, 0x73, 0x73, 0x52, 0x0e, 0x68, 0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74,
	0x43, 0x6c, 0x61, 0x73, 0x73, 0x1a, 0xb3, 0x02, 0x0a, 0x0e, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
	0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x79, 0x6d, 0x62,
	0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c,
	0x12, 0x7a, 0x0a, 0x11, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x4d, 0x2e, 0x6c, 0x69,
	0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e,
	0x4f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x2e, 0x53, 0x79, 0x6d, 0x62, 0x6f,
	0x6c, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x52, 0x10, 0x72, 0x65, 0x6c, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x35, 0x0a, 0x16,
	0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x5f, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x15, 0x6f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x22, 0x56, 0x0a, 0x10, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x68, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x55, 0x6e, 0x73, 0x70, 0x65,
	0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68,
	0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x44, 0x65, 0x66, 0x69,
	0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x52, 0x65,
	0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x6f, 0x10, 0x02, 0x22, 0x2f, 0x0a, 0x0e, 0x48,
	0x69, 0x67, 0x68, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x1d, 0x0a,
	0x19, 0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x48, 0x69, 0x67, 0x68,
	0x6c, 0x69, 0x67, 0x68, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x10, 0x00, 0x22, 0xe1, 0x04, 0x0a,
	0x11, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x12, 0x4d, 0x0a, 0x07, 0x70, 0x61,
	0x63, 0x6b, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x6c, 0x69,
	0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x49, 0x6e, 0x66,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
	0x52, 0x07, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x6f, 0x63,
	0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0d, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x58, 0x0a, 0x09, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74,
	0x65, 0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x53, 0x79,
	0x6d, 0x62, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09,
	0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x1a, 0x60, 0x0a, 0x07, 0x50, 0x61, 0x63,
	0x6b, 0x61, 0x67, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f,
	0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x70,
	0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x12, 0x12, 0x0a,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x1a, 0x82, 0x02, 0x0a, 0x0e,
	0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16,
	0x0a, 0x06, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x12, 0x78, 0x0a, 0x11, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x4b, 0x2e, 0x6c, 0x69, 0x62, 0x2e, 0x63, 0x6f, 0x64, 0x65, 0x69, 0x6e, 0x74, 0x65,
	0x6c, 0x2e, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2e, 0x53, 0x79, 0x6d,
	0x62, 0x6f, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x53,
	0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x52, 0x10,
	0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65,
	0x22, 0x5e, 0x0a, 0x10, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x55, 0x6e, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
	0x69, 0x65, 0x64, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x54,
	0x79, 0x70, 0x65, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x79, 0x70, 0x65, 0x52, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x6f, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x49, 0x6d,
	0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x10, 0x02,
	0x42, 0x3e, 0x5a, 0x3c, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x6c, 0x69, 0x62, 0x2f, 0x63, 0x6f, 0x64, 0x65, 0x69,
	0x6e, 0x74, 0x65, 0x6c, 0x2f, 0x6c, 0x73, 0x69, 0x66, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x2f,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_lib_codeintel_lsif_typed_lsif_proto_rawDescOnce sync.Once
	file_lib_codeintel_lsif_typed_lsif_proto_rawDescData = file_lib_codeintel_lsif_typed_lsif_proto_rawDesc
)

func file_lib_codeintel_lsif_typed_lsif_proto_rawDescGZIP() []byte {
	file_lib_codeintel_lsif_typed_lsif_proto_rawDescOnce.Do(func() {
		file_lib_codeintel_lsif_typed_lsif_proto_rawDescData = protoimpl.X.CompressGZIP(file_lib_codeintel_lsif_typed_lsif_proto_rawDescData)
	})
	return file_lib_codeintel_lsif_typed_lsif_proto_rawDescData
}

var file_lib_codeintel_lsif_typed_lsif_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_lib_codeintel_lsif_typed_lsif_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_lib_codeintel_lsif_typed_lsif_proto_goTypes = []interface{}{
	(Metadata_ProtocolVersion)(0),                            // 0: lib.codeintel.lsif_typed.Metadata.ProtocolVersion
	(Metadata_Encoding)(0),                                   // 1: lib.codeintel.lsif_typed.Metadata.Encoding
	(Document_Occurrence_HighlightClass)(0),                  // 2: lib.codeintel.lsif_typed.Document.Occurrence.HighlightClass
	(Document_Occurrence_SymbolRelation_RelationshipType)(0), // 3: lib.codeintel.lsif_typed.Document.Occurrence.SymbolRelation.RelationshipType
	(SymbolInformation_SymbolRelation_RelationshipType)(0),   // 4: lib.codeintel.lsif_typed.SymbolInformation.SymbolRelation.RelationshipType
	(*PackedIndex)(nil),                                      // 5: lib.codeintel.lsif_typed.PackedIndex
	(*IndexMessage)(nil),                                     // 6: lib.codeintel.lsif_typed.IndexMessage
	(*Metadata)(nil),                                         // 7: lib.codeintel.lsif_typed.Metadata
	(*Document)(nil),                                         // 8: lib.codeintel.lsif_typed.Document
	(*SymbolInformation)(nil),                                // 9: lib.codeintel.lsif_typed.SymbolInformation
	(*Metadata_ToolInfo)(nil),                                // 10: lib.codeintel.lsif_typed.Metadata.ToolInfo
	(*Document_Occurrence)(nil),                              // 11: lib.codeintel.lsif_typed.Document.Occurrence
	(*Document_Occurrence_SymbolRelation)(nil),               // 12: lib.codeintel.lsif_typed.Document.Occurrence.SymbolRelation
	(*SymbolInformation_Package)(nil),                        // 13: lib.codeintel.lsif_typed.SymbolInformation.Package
	(*SymbolInformation_SymbolRelation)(nil),                 // 14: lib.codeintel.lsif_typed.SymbolInformation.SymbolRelation
}
var file_lib_codeintel_lsif_typed_lsif_proto_depIdxs = []int32{
	7,  // 0: lib.codeintel.lsif_typed.PackedIndex.metadata:type_name -> lib.codeintel.lsif_typed.Metadata
	8,  // 1: lib.codeintel.lsif_typed.PackedIndex.documents:type_name -> lib.codeintel.lsif_typed.Document
	9,  // 2: lib.codeintel.lsif_typed.PackedIndex.symbol_information:type_name -> lib.codeintel.lsif_typed.SymbolInformation
	7,  // 3: lib.codeintel.lsif_typed.IndexMessage.metadata:type_name -> lib.codeintel.lsif_typed.Metadata
	8,  // 4: lib.codeintel.lsif_typed.IndexMessage.document:type_name -> lib.codeintel.lsif_typed.Document
	9,  // 5: lib.codeintel.lsif_typed.IndexMessage.symbol_information:type_name -> lib.codeintel.lsif_typed.SymbolInformation
	0,  // 6: lib.codeintel.lsif_typed.Metadata.protocol_version:type_name -> lib.codeintel.lsif_typed.Metadata.ProtocolVersion
	10, // 7: lib.codeintel.lsif_typed.Metadata.tool_info:type_name -> lib.codeintel.lsif_typed.Metadata.ToolInfo
	1,  // 8: lib.codeintel.lsif_typed.Metadata.text_document_encoding:type_name -> lib.codeintel.lsif_typed.Metadata.Encoding
	11, // 9: lib.codeintel.lsif_typed.Document.occurrences:type_name -> lib.codeintel.lsif_typed.Document.Occurrence
	13, // 10: lib.codeintel.lsif_typed.SymbolInformation.package:type_name -> lib.codeintel.lsif_typed.SymbolInformation.Package
	14, // 11: lib.codeintel.lsif_typed.SymbolInformation.relatives:type_name -> lib.codeintel.lsif_typed.SymbolInformation.SymbolRelation
	12, // 12: lib.codeintel.lsif_typed.Document.Occurrence.relatives:type_name -> lib.codeintel.lsif_typed.Document.Occurrence.SymbolRelation
	2,  // 13: lib.codeintel.lsif_typed.Document.Occurrence.highlight_class:type_name -> lib.codeintel.lsif_typed.Document.Occurrence.HighlightClass
	3,  // 14: lib.codeintel.lsif_typed.Document.Occurrence.SymbolRelation.relationship_type:type_name -> lib.codeintel.lsif_typed.Document.Occurrence.SymbolRelation.RelationshipType
	4,  // 15: lib.codeintel.lsif_typed.SymbolInformation.SymbolRelation.relationship_type:type_name -> lib.codeintel.lsif_typed.SymbolInformation.SymbolRelation.RelationshipType
	16, // [16:16] is the sub-list for method output_type
	16, // [16:16] is the sub-list for method input_type
	16, // [16:16] is the sub-list for extension type_name
	16, // [16:16] is the sub-list for extension extendee
	0,  // [0:16] is the sub-list for field type_name
}

func init() { file_lib_codeintel_lsif_typed_lsif_proto_init() }
func file_lib_codeintel_lsif_typed_lsif_proto_init() {
	if File_lib_codeintel_lsif_typed_lsif_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PackedIndex); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IndexMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Metadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Document); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SymbolInformation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Metadata_ToolInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Document_Occurrence); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Document_Occurrence_SymbolRelation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SymbolInformation_Package); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SymbolInformation_SymbolRelation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_lib_codeintel_lsif_typed_lsif_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*IndexMessage_Metadata)(nil),
		(*IndexMessage_Document)(nil),
		(*IndexMessage_SymbolInformation)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_lib_codeintel_lsif_typed_lsif_proto_rawDesc,
			NumEnums:      5,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_lib_codeintel_lsif_typed_lsif_proto_goTypes,
		DependencyIndexes: file_lib_codeintel_lsif_typed_lsif_proto_depIdxs,
		EnumInfos:         file_lib_codeintel_lsif_typed_lsif_proto_enumTypes,
		MessageInfos:      file_lib_codeintel_lsif_typed_lsif_proto_msgTypes,
	}.Build()
	File_lib_codeintel_lsif_typed_lsif_proto = out.File
	file_lib_codeintel_lsif_typed_lsif_proto_rawDesc = nil
	file_lib_codeintel_lsif_typed_lsif_proto_goTypes = nil
	file_lib_codeintel_lsif_typed_lsif_proto_depIdxs = nil
}
