package bloomfilter

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"io/ioutil"
	"math"
	"unicode"
	"unicode/utf16"
)

// BloomFilterBits is the number of bits allocated for new bloom filters.
//
// This parameter, along with BloomFilterNumHashFunctions (defined below),
// gives us a 1 in 1.38x10^9 false positive rate if we assume that the number
// of unique URIs referrable by an external package is of the order of 10k.
//
// See the following link for a bloom calculator: https://hur.st/bloomfilter.
const BloomFilterBits = 64 * 1024

// BloomFilterNumHashFunctions is the number of hash functions to use to
// determine if a value is a member of the filter.
const BloomFilterNumHashFunctions = 16

// TODO(efritz) - document
func CreateFilter(identifiers []string) ([]byte, error) {
	buckets := make([]int, BloomFilterBits)
	for _, identifier := range identifiers {
		addToFilter(buckets, BloomFilterNumHashFunctions, identifier)
	}

	return encodeFilter(buckets, int32(BloomFilterNumHashFunctions))
}

// decodeAndTestFilter decodes the filter and determines if identifier is a member of the underlying
// set. Returns an error if the encoded filter is malformed (improperly compressed or invalid JSON).
func DecodeAndTestFilter(encodedFilter []byte, identifier string) (bool, error) {
	buckets, numHashFunctions, err := decodeFilter(encodedFilter)
	if err != nil {
		return false, err
	}

	//
	// TODO - document bloom filter behaviors
	//

	return testFilter(buckets, numHashFunctions, identifier), nil
}

// TODO(efritz) - document
func decodeFilter(encodedFilter []byte) ([]int, int32, error) {
	payload := struct {
		Buckets          []int `json:"buckets"`
		NumHashFunctions int32 `json:"numHashFunctions"`
	}{}

	r, err := gzip.NewReader(bytes.NewReader(encodedFilter))
	if err != nil {
		return nil, 0, err
	}

	f, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, 0, err
	}

	if err := json.Unmarshal(f, &payload); err != nil {
		return nil, 0, err
	}

	return payload.Buckets, payload.NumHashFunctions, nil
}

// TODO(efritz) - document
func encodeFilter(buckets []int, numHashFunctions int32) ([]byte, error) {
	serialized, err := json.Marshal(map[string]interface{}{
		"buckets":          buckets,
		"numHashFunctions": numHashFunctions,
	})
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	w := gzip.NewWriter(&buf)
	if _, err := w.Write(serialized); err != nil {
		return nil, err
	}
	if err := w.Close(); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// TODO(efritz) - document
func testFilter(buckets []int, numHashFunctions int32, identifier string) bool {
	locations := hashLocations(
		identifier,
		int32(len(buckets))*32,
		numHashFunctions,
	)

	for _, b := range locations {
		if (buckets[int(math.Floor(float64(b)/32))] & (1 << (b % 32))) == 0 {
			return false
		}
	}

	return true
}

// TODO(efritz) - document
func addToFilter(buckets []int, numHashFunctions int, identifier string) {
	locations := hashLocations(
		identifier,
		int32(BloomFilterBits)*32,
		int32(BloomFilterNumHashFunctions),
	)

	for _, b := range locations {
		buckets[int(math.Floor(float64(b)/32))] |= (1 << (b % 32))
	}
}

// The following code is a port of bloomfilter 0.0.18 from npm. We chose not to recreate all the bloom
// filters stored in Postgres because we want a transitionary period where both services (TS and Go) can
// exist and be behaviorally equivalent.
//
// There are not a large number of differences, but there are some subtle ones around overflow behavior
// and UTF-8/16 encoding. The accompanying test suite uses filters generated by the original TypeScript
// code to ensure that they can be read without a migration step. We may want to run a migration step to
// simplify this dependency, but it is in no way urgent.
//
// The original code available at https://github.com/jasondavies/bloomfilter.js.

// Original notes:
// See http://willwhim.wpengine.com/2011/09/03/producing-n-hash-functions-by-hashing-only-once/.
func hashLocations(v string, m, k int32) []int32 {
	a := fowlerNollVo1a(v, 0)
	b := fowlerNollVo1a(v, 1576284489) // The seed value is chosen randomly
	x := a % int32(m)
	r := make([]int32, k)

	for i := int32(0); i < k; i++ {
		if x < 0 {
			r[i] = x + int32(m)
		} else {
			r[i] = x
		}
		x = (x + b) % int32(m)
	}

	return r
}

// Original notes:
// Fowler/Noll/Vo hashing. This function optionally takes a seed value that is incorporated
// into the offset basis. Almost any choice of offset basis will serve so long as it is non-zero,
// according to http://www.isthe.com/chongo/tech/comp/fnv/index.html.
func fowlerNollVo1a(v string, seed int32) int32 {
	q := 2166136261
	a := int64(int32(q) ^ seed)

	for _, r := range utf16Runes(v) {
		c := int64(r)
		if d := c & 0xff00; d != 0 {
			a = (fowlerNollVoMultiply(int32(a ^ int64(d>>8))))
		}
		a = fowlerNollVoMultiply(int32(a) ^ int32(c&0xff))
	}

	return fowlerNollVoMix(int32(a))
}

// Original notes:
// Equivalent to `a * 16777619 mod 2**32`.
func fowlerNollVoMultiply(a int32) int64 {
	return (int64(a) + int64(a<<1) + int64(a<<4) + int64(a<<7) + int64(a<<8) + int64(a<<24))
}

// Original notes:
// See https://web.archive.org/web/20131019013225/http://home.comcast.net/~bretm/hash/6.html.
func fowlerNollVoMix(a int32) int32 {
	a += a << 13
	a ^= int32(uint32(a) >> 7)
	a += a << 3
	a ^= int32(uint32(a) >> 17)
	a += a << 5
	return a
}

// utf16Runes converts the given string into a slice of UTF-16 encoded runes. This works by
// determining if each rune is a UTF-16 surrogate pair. If it is, we replace the rune with
// both runes composing the surrogate pair. Otherwise, we leave the original rune alone.
//
// This is a necessary step as existing filters were created in TypeScript, which treated
// strings as encoded in UTF-16, not UTF-8. We need to do this translation for runes that
// fall outside of the basic multilingual plane, or we wont be able to retrieve the original
// identifiers.
func utf16Runes(v string) []rune {
	var runes []rune
	for _, r := range v {
		// If the pair is not surrogate, U+FFFD is returned for both runes
		if a, b := utf16.EncodeRune(r); a == unicode.ReplacementChar && b == unicode.ReplacementChar {
			runes = append(runes, r)
		} else {
			runes = append(runes, a, b)
		}
	}

	return runes
}
