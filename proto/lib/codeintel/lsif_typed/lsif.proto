/**
 * An index contains one or more pieces of information about a given piece of
 * source code or software artifact. Complementary information can be merged
 * together from multiple sources to provide a unified code intelligence
 * experience.
 *
 * Programs producing a file of this format is an "indexer" and may operate
 * somewhere on the spectrum between precision, such as indexes produced by
 * compiler-backed indexers, and heurstics, such as indexes produced by local
 * syntax-directed analysis for scope rules.
 *
 * See the `Index` message for additional documentation.
 */
syntax = "proto3";

package lib.codeintel.lsif_typed;

option go_package = "github.com/sourcegraph/sourcegraph/lib/codeintel/lsif_typed/";

/**
 * A representation of an index that can be emitted and consumed as as single
 * message payload. An index may also be represented by a length-prefixed stream
 * of index messages with the following ordering constraints:
 *
 * 1. The first message in the stream must provide metadata, and must be the
 * only message to do so.
 * 2. If a document references a symbol, the associated symbol information, if
 * it exists, must have preceeded the document in the stream. This allows a
 * document to be fully-processed once encountered. Note that symbols may
 * reference each other, and a symbol object may not be logically "closed" until
 * the end of the stream and some use cases will still be required to read the
 * stream to completion.
 *
 * These constraints allow the index to be processed with minimal bookkeeping
 * overhead, and allows partial processing to stop early on successful match.
 */
message Index {
  /**
   * (Required) Metadata about this index such as tool and protocol versioning
   * and identification of the indexing environment.
   */
  Metadata metadata = 1;

  // Documents that belong to this index or the packages that are defined by
  // this index.
  repeated Document document = 2;
  // Packages that are either referenced from this index or the packages that
  // are defined by this index.
  repeated Package package = 3;
  // Symbols that are defined outside of this index but are referenced from
  // inside this index.
  repeated Symbol external_symbols = 4;
}

/**
 * Metadata contains tool and protocol version information, indexer
 * self-identification, and data that encodes the indexing environment. Unlike
 * the other messages defined in this index, the contents of this message may
 * not be "stable" bewteen indexer invocations producing the same logical index
 * For example, `Metadata.project_root` encodes the local working directory.
 */
message Metadata {
  /**
   * (Required) An explicit version of the encoding used for this index. Changes
   * to this value may change the interpretation of parsed strings (such as
   * symbol identifiers) in tools consuming the index.
   */
  ProtocolVersion protocol_version = 1;

  /**
   * Possible index protocol versions.
   */
  enum ProtocolVersion {
    /**
     * Currently, the only version available while the protocol is in
     * design-flux. Once we are reasonably sure about the direction of this
     * protocol, we will create a new non-zero version and enforce a version
     * check in consumers for safety and forwards-compatibility.
     */
    UnspecifiedProtocolVersion = 0;
  }

  /**
   * (Required) Information about the tool that created the index.
   */
  ToolInfo tool_info = 2;

  /**
   * (Required) A URI-encoded absolute path to the root directory of this
   * index. The documents also contained in the associated index are defined
   * relative to this directory.
   */
  string project_root = 3;

  /**
   * (Required) The string encoding used to compute correct text selections
   * within the text documents defining the indexed source code. Positions
   * within text documents are expressed as zero-based line and character
   * offsets based on the string representations of the text with the given
   * encoding.
   */
  TextDocumentEncoding text_document_encoding = 4;

  /**
   * Possible text document encodings.
   */
  enum TextDocumentEncoding {
    /**
     * (Invalid) Unknown encoding. Consumers may attempt to choose a sane
     * default or auto-detect an encoding of text documents when rendering
     * selections of code.
     */
    UnspecifiedEncoding = 0;

    /**
     * Text documents are encoded in UTF-8.
     */
    UTF8 = 1;

    /**
     * Text documents are encoded in UTF-16 (e.g., TypeScript).
     */
    UTF16 = 2;
  }
}

/**
 * A description of the indexer (and the invocation) that produced a specific
 * index.
 */
message ToolInfo {
  /**
   * (Required) The name of the tool that created a specific index.
   */
  string name = 1;

  /**
   * (Required) The version of the tool that created a specific index.
   */
  string version = 2;

  /**
   * (Required) The list of command line arguments supplied to the indexer
   * that created a specific index.
   */
  repeated string arguments = 3;
}

// Document defines information about a particular source file.
message Document {
  // Relative path to the `Index.project_root` directory.
  string relative_path = 1;
  // Symbol occurrences that appear in this file.
  repeated Occurrence occurrences = 2;
  // Symbols that are defined within this document.
  repeated Symbol symbols = 3;
}

// Package defines a publishable artifact such as an npm package, Docker
// container, JVM dependency, or a Cargo crate.
message Package {
  // The unique identifier of this package that can be referenced from
  // `Symbol.package_uri`.  This URI is not intended to be displayed to humans,
  // but it's recommended to use a human-readable format to aid with debugging.
  string uri = 1;
  // Name of this package, for example "@types/react" or
  // "com.google.guava:guava".
  string name = 2;
  // Version of this package, for example "0.1.0" or "2.1.5".
  string version = 3;
  // Package manager, for example "npm", "maven" or "cargo".
  string manager = 4;
}

// Symbol defines a symbol, such as a function or an interface.
message Symbol {
  enum Unique {
    UNIQUE_UNSPECIFIED = 0;
    UNIQUE_DOCUMENT = 1;
    UNIQUE_GLOBAL = 2;
  }
  // The identifier of this symbol, which can be referenced from
  // Occurence. An empty uri means this symbol can be ignored.
  string uri = 1;
  // Determines whether this symbol is local to a single document or if can be
  // referenced from multiple documents.
  // Document symbols (`Document.symbols`) can be either local or global.
  // External symbols (`Index.external_symbols`) must be global.
  Unique unique = 2;
  // (optional, but strongly recommended) The markdown-formatted documentation
  // for this symbol. This field is repeated to allow different kinds of
  // documentation.  For example, it's nice to include both the signature of a
  // method (parameters and return type) along with the accompanying docstring.
  repeated string documentation = 3;
  // (optional) Links to the original package that defines this symbol to
  // enable navigation across different LSIF indexes (whether they come from
  // different projects or git repositories). This field must be non-empty for
  // toplevel symbols (`Value.value`).
  string package_uri = 4;
  // (optional) Symbols that should be included together with this symbol when
  // resolving "find references".  For example, the symbol of a TypeScript or
  // Java method that implements an interface method should list the interface
  // method here.
  repeated string reference_symbols = 5;
  // (optional) Symbols that are "implemented" by this symbol. For example,
  // the symbol of a TypeScript or Java class that implements an interface
  // should list the interface here.
  repeated string implementation_symbols = 6;
}

// Occurrence associates a source position with a symbol and/or highlighting
// information.
message Occurrence {
  enum Role {
    ROLE_UNSPECIFIED = 0;
    ROLE_DEFINITION = 1;
    ROLE_REFERENCE = 2;
  }
  enum Highlight {
    HIGHLIGHT_UNSPECIFIED = 0;
    HIGHLIGHT_STRING_LITERAL = 1;
    HIGHLIGHT_NUMERIC_LITERAL = 2;
    HIGHLIGHT_IDENTIFIER = 3;
    HIGHLIGHT_METHOD_IDENTIFIER = 4;
    HIGHLIGHT_TYPE_IDENTIFIER = 5;
    HIGHLIGHT_TERM_IDENTIFIER = 6;
    HIGHLIGHT_LOCAL_IDENTIFIER = 7;
    HIGHLIGHT_SHADED_IDENTIFIER = 8;
    HIGHLIGHT_PACKAGE_IDENTIFIER = 9;
  }
  // The source position of this occurrence. Must be exactly three or four
  // elements:
  //
  // - Four elements: `[startLine, startCharacter, endLine, endCharacter]`
  // - Three elements: `[startLine, startCharacter, endCharacter] (endLine ==
  // startLine)`
  //
  // Line numbers and characters are always 0-based. Make sure to increment the
  // line/character values before displaying them in an editor-like UI because
  // editors conventionally use 1-based numbers.
  //
  // Ranges appear frequently in real-world LSIF payloads, the `repeated int32`
  // encoding was chosen over the LSP `Range(start:Position,end:Position)`
  // encoding for performance reasons.  Benchmarks reveal that this change alone
  // reduces the total payload size by ~2x in both compressed JSON or Protobuf
  // encoding. This encoding is admittedly more embarrassing to work with in
  // some programming languages but we hope the increased performance
  // improvements make up for it.
  repeated int32 range = 1;
  // (optional) References the `Symbol.uri` field. Can be empty if this is only
  // a highlighting occurrence.
  string symbol_uri = 2;
  // (optional) Is the symbol_uri defined or referenced at this occurrence?
  Role symbol_role = 3;
  // (optional) Markdown-formatted documentation for this specific range.  If
  // empty, the `Symbol.documentation` field is used instead. One example
  // where this field might be useful is when the symbol represents a generic
  // function (with abstract type parameters such as `List<T>`) and at this
  // occurrence we know the exact values (such as `List<String>`).
  repeated string symbol_documentation = 4;
  // (optional) What syntax highlighting class should be used for this range?
  Highlight highlight = 5;
}
