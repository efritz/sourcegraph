/**
 * An index contains one or more dimensions of intelligence about a given piece
 * of source code or software artifact. Complimentary dimensions can be merged
 * together from multiple sources to provide a unified code intelligence
 * experience.
 *
 * Programs producing a file of this format is an "indexer" and may operate
 * somewhere on the spectrum between precision, such as indexes produced by
 * compiler-backed indexers, and heurstics, such as indexes produced by local
 * syntax-directed analysis for scope rules.
 *
 * Indexes can be emitted and consumed "packed" or "streamed". See `PackedIndex`
 * and `IndexMessage`, respectively, for additional documentation.
 */
syntax = "proto3";

package lib.codeintel.lsif_typed;
option go_package = "github.com/sourcegraph/sourcegraph/lib/codeintel/lsif_typed/";

/**
 * A representation of an index that can be emitted and consumed as as single
 * message payload. To write and consume a stream of messages instead, see
 * `IndexMessage`.
 */
message PackedIndex {
  /**
   * (Required) Metadata about this index such as tool and protocol versioning
   * and identification of the indexing environment.
   */
  Metadata metadata = 1;

  /**
   * (Optional) Representations of decorated text documents that compose the
   * analyzed source of this index.
   */
  repeated Document documents = 2;

  /**
   * (Optional) Representations of objects within the analyzed source of this
   * index. Referenced by one or more occurrences within the documents of this
   * index, or externally from another index (by uniquely defined identifiers).
   */
  repeated SymbolInformation symbol_information = 3;
}

/**
 * A representation of a portion of an index. An entire index can be represented
 * by a length-prefixed stream of index messages with the following ordering
 * constraints:
 *
 * 1. The first message in the stream is (the only) metadata message.
 * 2. All symbol messages are emitted before any document message that
 * references it. Note that symbols may reference each other, and a symbol
 * object may not be logically "closed" until the end of the stream.
 *
 * These constraints allow the index to be processed with minimal bookkeeping
 * overhead, and allows partial processing to stop early on successful match.
 */
message IndexMessage {
  /**
   * Union of message payload types.
   */
  oneof value {
    /**
     * Metadata about this index such as tool and protocol
     * versioning and identification of the indexing environment.
     */
    Metadata metadata = 1;

    /**
     * A representation of a decorated text document contained in in
     * the analyzed source of this index.
     */
    Document document = 2;

    /**
     * A representation of an object within the analyzed source of this index.
     * Referenced by one or more occurrences within the documents of this index,
     * or externally from another index (by uniquely defined identifiers).
     */
    SymbolInformation symbol_information = 3;
  }
}

/**
 * Metadata contains tool and protocol version information, indexer
 * self-identification, and data that encodes the indexing environment. Unlike
 * the other messages defined in this index, the contents of this message may
 * not be "stable" bewteen indexer invocations producing the same logical index
 * (for example, `Metadata.project_root` encodes the local working directory).
 */
message Metadata {
  /**
   * (Required) An explicit version of the encoding used for this index. Changes
   * to this value may change the interpretation of parsed strings (such as
   * symbol identifiers) in tools consuming the index.
   */
  ProtocolVersion protocol_version = 1;

  /**
   * Possible index protocol versions.
   */
  enum ProtocolVersion {
    /**
     * Currently, the only version available while the protocol is in
     * design-flux. Once we are reasonably sure about the direction of this
     * protocol, we will create a new non-zero version and enforce a version
     * check in consumers for safety and forwards-compatibility.
     */
    UnspecifiedProtocolVersion = 0;
  }

  /**
   * (Required) Information about the tool that created the index.
   */
  ToolInfo tool_info = 2;

  /**
   * A description of the indexer (and the invocation) that produced the
   * associated index.
   */
  message ToolInfo {
    /**
     * (Required) The name of the tool that created the associated index.
     */
    string name = 1;

    /**
     * (Required) The version of the tool that created the associated index.
     */
    string version = 2;

    /**
     * (Required) The list of command line arguments supplied to the indexer
     * that created the associated index.
     */
    repeated string arguments = 3;
  }

  /**
   * (Required) A URI-encoded absolute path to the root directory of this
   * index. The documents also contained in the associated index are defined
   * relative to this directory.
   */
  string project_root = 3;

  /**
   * (Required) The string encoding used to compute correct text selections
   * within the text documents defining the indexed source code. Positions
   * within text documents are expressed as zero-based line and character
   * offsets based on the string representations of the text with the given
   * encoding.
   */
  Encoding text_document_encoding = 4;

  /**
   * Possible text document encodings.
   */
  enum Encoding {
    /**
     * (Invalid) Unknown encoding. Consumers may attempt to choose a sane
     * default or auto-detect an encoding of text documents when rendering
     * selections of code.
     */
    UnspecifiedEncoding = 0;

    /**
     * Text documents are encoded in UTF-8.
     */
    UTF8 = 1;

    /**
     * Text documents are encoded in UTF-16 (e.g., TypeScript).
     */
    UTF16 = 2;
  }
}

/**
 * A representation a text document belonging to the associated index decorated
 * with addiditonal intelligence. We assume that all relevant indexed documents
 * can be represented as a string. There is currently no support for binary
 * documents. The character encoding of a document is delcared by the associated
 * index's `Metadata.text_document_encoding` field.
 */
message Document {
  /**
   * (Required) The path to the text document relative to the directory supplied
   * in the associated `Index.project_root`. This value should not begin with a
   * directory separator.
   */
  string relative_path = 1;

  /**
   * (Optional) A set of occurrences that provide additional intelligence for
   * some selection of source text within the document.
   */
  repeated Occurrence occurrences = 2;

  /**
   * An occurrence associates a selection of source text with additional code
   * intelligence, such as highlighting rules or answers to common code
   * navigation queries such as finding hover text, definitions, references,
   * or implementations of the symbol at a specific source text position.
   */
  message Occurrence {
    /**
     * (Required) A range of contiguous characters in the enclosing text
     * document expressed a half-open interval (start inclusive; end exclusive).
     *
     * Both line and character offsets are zero-based. Make sure to adjust line
     * and character values before displaying them in an editor-like UI as
     * editors conventionally count from one.
     *
     * This value must have exactly three or four elements of either the form
     * `[a, b, d]` or `[a, b, c, d]` where `a` is the starting line, `b` is the
     * starting column, `c` is the ending line, and `d` is the ending column.
     * The three-element form should only be usedÂ when `a = c`, i.e., the case
     * of single-line ranges. The initial encoding of ranges in this spec used a
     * `Range` message type that mirrors the structure of the equivalent type in
     * LSP. Benchmarks revealed we were able to reduce the total payload size of
     * the entire index by up to ~2x by using a `repeated int32` encoding
     * instead, which has an efficient packed encoding in Protobuf binary
     * payloads. efficient encoding. This value must have exactly three or four
     * elements of either the form `[a, b, d]` or `[a, b, c, d]` where `a` is
     * the starting line, `b` is the starting column, `c` is the ending line,
     * and `d` is the ending column. The three-element form should be used if
     * and only if `a = c`, i.e., the case of single-line ranges.
     *
     * Lines exceeding the document line count or characters exceeding the
     * length of the target line will be interpreted as the maximum valid value
     * given the text document contents (and according to its encoding).
     *
     * Special values like -1 to indicate the end of a line are not allowed. If
     * you want to specify a range that contains a line including the line
     * ending character(s) then use an end position denoting the start of the
     * next line.
     *
     * For example: `[5, 23, 6, 0]`
     */
    repeated uint32 range = 1;

    /**
     * (Optional) A set of (directed) relationships between this occurrence and
     * symbols also defined in the associated index. Values for this field may
     * not be provided if this occurrence is used only for highlighting.
     */
    repeated SymbolRelation relatives = 2;

    /**
     * A description of the relationship between a source occurrence and a
     * symbol.
     */
    message SymbolRelation {
      /**
       * (Required) A reference to the target `SymbolInformation.symbol`. This
       * symbol may be defined in the same associated index, or a remote one.
       */
      string symbol = 1;

      /**
       * (Required) The type of relationship between the target symbol and the
       * source occurrence. See `Document.SymbolRelation.relationship_type` for
       * additional documentation relating to each possible relationship type.
       */
      RelationshipType relationship_type = 2;

      /**
       * The type of relationship between an occurrence and a symbol.
       */
      enum RelationshipType {
        /**
         * (Invalid) Unknown relationship type.
         */
        UnspecifiedRelationshipType = 0;

        /**
         * The source occurrence defines the target symbol (e.g., `x` in `val x
         * = y`).
         */
        DefinitionOf = 1;

        /**
         * The source occurrence references the target symbol, which is defined
         * elsewhere (e.g., `y` in `val x = y`).
         */
        ReferenceTo = 2;
      }

      /**
       * (Optional) Range-specific overrides for the documentation string
       * defiend in the referenced symbol. This useful when the definition of a
       * symbol may be parameteric, but the usage of a symbol may have refined
       * typing information in the signature that would be more useful to
       * display.
       */
      repeated string override_documentation = 3;
    }

    /**
     * (Optional) The type of syntax highlighting class that should be used for
     * the associated range. If unspecified, no presentation properties are
     * prescribed.
     */
    HighlightClass highlight_class = 3;

    /**
     * Possible tags associated with a selection of text within a document used
     * for syntax or semantic-directed highlighting.
     */
    enum HighlightClass {
      /**
       * Unknown highlighting class. Do not apply special styling beyond the
       * default "code style" for the associated range.
       */
      UnspecifiedHighlightClass = 0;
    }
  }
}

/**
 * A representation of an object within the analyzed source of this index that
 * may be referenced by one or more occurrences within this index, or externally
 * from another index (by uniquely defined identifiers).
 */
message SymbolInformation {
  /**
   * (Required) An identifier of this symbol that uniquely identifies it
   * within the associated index. This value may be used to reference the entire
   * symbol information type from the fields
   * `Document.Occurrence.SymbolRelation` and `SymbolInformation.SymbolRelation`
   * also defined in the associated index.
   *
   * Identifiers must begin with a protocol declaration, specifically the
   * prefix `{scheme}://`, that determines whether or not the
   * remainder of the value cn be used to extract semantic value. Note that we
   * do not expect this value to be a valid or parseable URI, nor do we expect
   * any particular encoding of the remaining payload.
   *
   * Within a particular scheme, identifiers should be sufficiently unique so as
   * to avoid matching other symbols in other projects unless they actuall refer
   * to the same symbol. Symbol identifiers should be position-independent and
   * stable so that they can be used to identify symbols between documents and
   * projects.
   */
  string symbol = 1;

  /**
   * (Optional) The package in which this symbol is defined. Package values are
   * compared bewteen distinct indexes to enable global navigation.
   */
  Package package = 2;

  /**
   * Package describes a publishable, versioned, and uniquely identifiable
   * artifact such as a Go module, an NPM or Python package, a Docker container,
   * a JVM dependency, or a Cargo crate.
   */
  message Package {
    /**
     * (Required) The name of the package manager (e.g., `gomod`, `npm`,
     * `maven`).
     */
    string package_manager = 1;

    /**
     * (Required) The name of this package (e.g., `@types/react`,
     * `com.google.guava:guava`).
     */
    string name = 2;

    /**
     * (Required) The version of this package (e.g., `0.1.0`, `2.1.5`).
     */
    string version = 3;
  }

  /**
   * (Optional) The documentation payload for this symbol encoded as markdown.
   * This field is repeated to allow different kinds of documentation. For
   * example, separating signature from description.
   */
  repeated string documentation = 3;

  /**
   * (Optional) A set of (directed) relationships between this symbol and other
   * symbols also defined in the associated index. These relationships define
   * groups of symbols that should be transitively evaluated and treated as one
   * entity when resolving specific types of code navigation queries. See
   * `SymbolInformation.SymbolRelation.relationship_type` for additional
   * documentation.
   */
  repeated SymbolRelation relatives = 4;

  /**
   * A description of the relationship between two symbols.
   */
  message SymbolRelation {
    /**
     * (Required) A reference to the target `SymbolInformation.symbol`. This
     * symbol may be defined in the same associated index, or a remote one.
     */
    string symbol = 1;

    /**
     * (Required) The type of relationship between the target symbol and the
     * source symbol. See `SymbolInformation.SymbolRelation.relationship_type`
     * for additional documentation relating to each possible relationship type.
     */
    RelationshipType relationship_type = 2;

    /**
     * The type of relationship between two symbols.
     */
    enum RelationshipType {
      /**
       * (Invalid) Unknown relationship type.
       */
      UnspecifiedRelationshipType = 0;

      /**
       * The source symbol has a type described by the target symbol.
       *
       * For example, symbols `s{1..3}` are all type references to symbol `S` in
       * the following:
       *
       * ```go
       * type S struct {}  // def S
       * var s1, s2, s3 S  // def s{1..3}, ref S
       * _ = s1            // ref s1
       * ```
       *
       * This type of relationship affords the "Go to type definition" code
       * navigation action.
       */
      TypeReferenceTo = 1;

      /**
       * The source symbol is an implementation of the target symbol.
       *
       * For example, symbols `S` and `S.M` are respective implementations of
       * symbols `I` and `I.M` in the following:
       *
       * ```go
       * type I interface{ M() }  // def I, def I.M
       * type S struct{}          // def S
       * func (S) M() {}          // ref S, def S.M
       * ```
       *
       * This type of relationship affords us the "Go to interface" and "Find
       * implementations" code naviagation actions; it can also expand the set
       * of results for a "Find references" operation, where references of the
       * interface include references of concrete types as well, but not the
       * reverse.
       */
      ImplementationOf = 2;
    }
  }
}
